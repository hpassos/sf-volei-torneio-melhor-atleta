=== ./src\App.tsx ===
import React, { useState, useEffect } from 'react';
import { Trophy, Users, Swords, Vote, BarChart3, LayoutGrid } from 'lucide-react';
import AthleteRegistration from './components/AthleteRegistration';
import TeamFormation from './components/TeamFormation';
import SwordsC from './components/Swords';
import VotingSystem from './components/VotingSystem';
import Dashboard from './components/Dashboard';
import GroupStage from './components/GroupStage';
import { fetchData, updateData } from './services/jsonbin';
import type { Database } from './types';
import { initialData } from './types';

function App() {
  const [activeTab, setActiveTab] = useState('dashboard');
  const [data, setData] = useState<Database>(initialData);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      const fetchedData = await fetchData();
      setData(fetchedData);
      setError(null);
    } catch (err) {
      setError('Erro ao carregar dados. Por favor, tente novamente.');
    } finally {
      setLoading(false);
    }
  };

  const handleDataUpdate = async (newData: Database) => {
    try {
      setLoading(true);
      await updateData(newData);
      setData(newData);
      setError(null);
    } catch (err) {
      setError('Erro ao salvar dados. Por favor, tente novamente.');
    } finally {
      setLoading(false);
    }
  };

  const tabs = [
    { id: 'dashboard', label: 'Dashboard', icon: BarChart3 },
    { id: 'voting', label: 'Votação', icon: Vote },
    { id: 'athletes', label: 'Cadastro de Atletas', icon: Users },
    { id: 'teams', label: 'Formação de Duplas', icon: Trophy },
    { id: 'groups', label: 'Fase de Grupos', icon: LayoutGrid },
    { id: 'matches', label: 'Confrontos', icon: Swords },
  ];

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto"></div>
          <p className="mt-4 text-gray-600">Carregando...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-indigo-600 text-white py-6 shadow-lg">
        <div className="container mx-auto px-4">
          <h1 className="text-3xl font-bold">SF Vôlei</h1>
          <h3 className="text-2xl font-bold">1º Torneio Interno</h3>
        </div>
      </header>

      {/* Abas com rolagem horizontal */}
      <nav className="bg-white shadow-md">
        <div className="container mx-auto px-4">
          <div className="flex overflow-x-auto no-scrollbar">
            {tabs.map(({ id, label, icon: Icon }) => (
              <button
                key={id}
                onClick={() => setActiveTab(id)}
                className={`flex-shrink-0 flex items-center space-x-2 px-4 py-3 font-medium transition-colors ${activeTab === id
                  ? 'border-b-2 border-indigo-600 text-indigo-600'
                  : 'text-gray-600 hover:text-indigo-600'
                  }`}
              >
                <Icon className="h-5 w-5" />
                <span>{label}</span>
              </button>
            ))}
          </div>
        </div>
      </nav>

      <main className="container mx-auto px-4 py-8">
        {error && (
          <div className="mb-4 p-4 bg-red-100 text-red-700 rounded-lg">
            {error}
          </div>
        )}

        <div className="bg-white rounded-lg shadow-md p-6">
          {activeTab === 'dashboard' && <Dashboard data={data} />}
          {activeTab === 'athletes' && (
            <AthleteRegistration
              athletes={data.atletas}
              onUpdate={(athletes) => handleDataUpdate({ ...data, atletas: athletes })}
            />
          )}
          {activeTab === 'teams' && (
            <TeamFormation
              athletes={data.atletas}
              teams={data.duplas}
              onUpdate={(teams) => handleDataUpdate({ ...data, duplas: teams })}
            />
          )}
          {activeTab === 'matches' && (
            <SwordsC
              teams={data.duplas}
              matches={data.confrontos}
              onUpdate={(matches) => handleDataUpdate({ ...data, confrontos: matches })}
            />
          )}
          {activeTab === 'voting' && (
            <VotingSystem
              athletes={data.atletas}
              matches={data.confrontos}
              votes={data.votacoes}
              onUpdate={(votes) => handleDataUpdate({ ...data, votacoes: votes })}
            />
          )}
          {activeTab === 'groups' && (
            <GroupStage
              teams={data.duplas}
              matches={data.confrontos}
              onUpdateMatches={(matches) => handleDataUpdate({ ...data, confrontos: matches })}
            />
          )}
        </div>
      </main>
    </div>
  );
}

export default App;

=== ./src\index.css ===
@tailwind base;
@tailwind components;
@tailwind utilities;


=== ./src\main.tsx ===
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import App from './App.tsx';
import './index.css';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>
);


=== ./src\types.ts ===
export interface Athlete {
  id: string;
  nome: string;
}

export interface Team {
  id: number;
  atleta1: string;
  atleta2: string;
  grupo: string;
}

export interface Match {
  id: string;
  rodada: string;
  dupla1: string;
  dupla2: string;
  placar: {
    dupla1: number;
    dupla2: number;
  };
}

export interface Vote {
  votante: string;
  voto: string;
}

export interface RoundVotes {
  [key: string]: Vote[];
}

export interface Database {
  atletas: Athlete[];
  duplas: Team[];
  confrontos: Match[];
  votacoes: RoundVotes;
  grupos: Group[];
}

export const initialData: Database = {
  atletas: [],
  duplas: [],
  confrontos: [],
  votacoes: {},
  grupos: [],
};

=== ./src\vite-env.d.ts ===
/// <reference types="vite/client" />


=== ./src\components\AthleteRegistration.tsx ===
import React, { useState } from 'react';
import type { Athlete } from '../types';


interface Props {
  athletes: Athlete[];
  onUpdate: (athletes: Athlete[]) => void;
}

const generateId = () => {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  // Fallback para um ID simples (não é um UUID real)
  return Math.random().toString(36).substring(2, 9);
};

export default function AthleteRegistration({ athletes, onUpdate }: Props) {
  const [name, setName] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim()) return;

    const isDuplicate = athletes.some(athlete => athlete.nome === name.trim());
    if (isDuplicate) {
      alert('Atleta já cadastrado!');
      return;
    }

    const newAthlete: Athlete = {
      id: generateId(),
      nome: name.trim(),
    };

    onUpdate([...athletes, newAthlete]);
    setName('');
  };

  const handleDelete = (athleteId: string) => {
    const updatedAthletes = athletes.filter(athlete => athlete.id !== athleteId);
    onUpdate(updatedAthletes);
  };

  return (
    <div>
      <h2 className="text-2xl font-bold mb-6">Cadastro de Atletas</h2>

      <form onSubmit={handleSubmit} className="mb-8">
        <div className="flex gap-4">
          <input
            type="text"
            value={name}
            onChange={(e) => setName(e.target.value)}
            placeholder="Nome do atleta"
            className="flex-1 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
          />
          <button
            type="submit"
            className="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          >
            Adicionar Atleta
          </button>
        </div>
      </form>

      <div className="bg-gray-50 rounded-lg p-4">
        <h3 className="text-lg font-semibold mb-4">Atletas Cadastrados</h3>
        {athletes.length === 0 ? (
          <p className="text-gray-500">Nenhum atleta cadastrado</p>
        ) : (
          <ul className="space-y-2">
            {athletes.map((athlete) => (
              <li
                key={athlete.id}
                className="flex items-center justify-between bg-white p-3 rounded-md shadow-sm"
              >
                <span>{athlete.nome}</span>
                <button
                  onClick={() => handleDelete(athlete.id)}
                  className="text-red-600 hover:text-red-800 font-medium"
                  title="Remover atleta"
                >
                  Remover
                </button>
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>
  );
}

=== ./src\components\Dashboard.tsx ===
import React, { useMemo } from 'react';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend, ResponsiveContainer,
} from 'recharts';

import type { Database } from '../types';

interface Props {
  data: Database;
}

const COLORS = ['#4F46E5', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6'];

export default function Dashboard({ data }: Props) {
  // Estatísticas de atletas mais votados
  const voteStats = useMemo(() => {
    const stats: Record<string, number> = {};

    Object.values(data.votacoes).forEach(roundVotes => {
      roundVotes.forEach(vote => {
        stats[vote.voto] = (stats[vote.voto] || 0) + 1;
      });
    });

    return Object.entries(stats)
      .map(([name, votes]) => ({ name, votes }))
      .sort((a, b) => b.votes - a.votes);
  }, [data.votacoes]);

  // Estatísticas de atletas que mais votaram
  const votersStats = useMemo(() => {
    const stats: Record<string, number> = {};

    Object.values(data.votacoes).forEach(roundVotes => {
      roundVotes.forEach(vote => {
        stats[vote.votante] = (stats[vote.votante] || 0) + 1;
      });
    });

    return Object.entries(stats)
      .map(([name, votes]) => ({ name, votes }))
      .sort((a, b) => b.votes - a.votes);
  }, [data.votacoes]);

  const matchStats = useMemo(() => {
    const stats: Record<string, { wins: number; totalGames: number }> = {};

    data.confrontos.forEach(match => {
      const winner = match.placar.dupla1 > match.placar.dupla2 ? match.dupla1 : match.dupla2;
      const teams = [match.dupla1, match.dupla2];

      teams.forEach(team => {
        if (!stats[team]) {
          stats[team] = { wins: 0, totalGames: 0 };
        }
        stats[team].totalGames++;
        if (team === winner) {
          stats[team].wins++;
        }
      });
    });

    return Object.entries(stats).map(([team, { wins, totalGames }]) => ({
      team,
      winRate: (wins / totalGames) * 100,
    }));
  }, [data.confrontos]);

  return (
    <div>
      <h2 className="text-2xl font-bold mb-6">Resultados</h2>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
        {/* Seção de Atletas Mais Votados */}
        <div className="bg-white p-6 rounded-lg shadow-md">
          <h3 className="text-lg font-semibold mb-4">Atletas + completos</h3>
          <div className="mt-6 space-y-3">
            {voteStats.slice(0, 3).map((athlete, index) => (
              <div
                key={athlete.name}
                className="flex items-center justify-between p-3 bg-indigo-50 rounded-lg"
              >
                <div className="flex items-center space-x-2">
                  <span className="font-bold text-indigo-600">
                    #{index + 1}
                  </span>
                  <span className="font-medium">{athlete.name}</span>
                </div>
                <span className="bg-indigo-600 text-white px-3 py-1 rounded-full text-sm">
                  {athlete.votes} votos
                </span>
              </div>
            ))}
          </div>
        </div>

        {/* Nova Seção: Atletas que Mais Votaram */}
        <div className="bg-white p-6 rounded-lg shadow-md">
          <h3 className="text-lg font-semibold mb-4">Atletas que votaram</h3>

          <div className="space-y-3">
            {votersStats.slice(0, 3).map((voter, index) => (
              <div
                key={voter.name}
                className="flex items-center justify-between p-3 bg-emerald-50 rounded-lg"
              >
                <div className="flex items-center space-x-2">
                  <span className="font-bold text-emerald-600">
                    #{index + 1}
                  </span>
                  <span className="font-medium">{voter.name}</span>
                </div>
                <span className="bg-emerald-600 text-white px-3 py-1 rounded-full text-sm">
                  {voter.votes} votos
                </span>
              </div>
            ))}
          </div>
        </div>

        {/* Seção de Taxa de Vitória */}
        <div className="bg-white p-6 rounded-lg shadow-md">
          <h3 className="text-lg font-semibold mb-4">Taxa de Vitória por Dupla</h3>
          <div className="flex justify-center">
            <BarChart width={400} height={300} data={matchStats}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="team" angle={-45} textAnchor="end" height={100} />
              <YAxis label={{ value: 'Taxa de Vitória (%)', angle: -90, position: 'insideLeft' }} />
              <Tooltip />
              <Bar dataKey="winRate" fill="#4F46E5" />
            </BarChart>
          </div>


        </div>
      </div>
    </div>
  );
};

=== ./src\components\GroupStage.tsx ===
import React, { useState, useEffect } from 'react';
import type { Team, Match, Group } from '../types';

interface Props {
  teams: Team[];
  matches: Match[];
  onUpdateMatches: (matches: Match[]) => void;
}

export default function GroupStage({ teams, matches, onUpdateMatches }: Props) {
  const [groups, setGroups] = useState<Group[]>([]);
  const [selectedMatch, setSelectedMatch] = useState<Match | null>(null);
  const [tempScore, setTempScore] = useState({ dupla1: 0, dupla2: 0 });

  useEffect(() => {
    const grouped = teams.reduce((acc: { [key: string]: Team[] }, team) => {
      const groupName = team.grupo || 'Sem Grupo';
      if (!acc[groupName]) acc[groupName] = [];
      acc[groupName].push(team);
      return acc;
    }, {});

    const formattedGroups = Object.entries(grouped).map(([name, teams]) => ({
      id: name,
      name,
      teams
    }));

    setGroups(formattedGroups);
  }, [teams]);

  const isValidScore = (score1: number, score2: number) => {
    const maxScore = Math.max(score1, score2);
    const minScore = Math.min(score1, score2);
    return (maxScore === 21 && minScore < 20) || (maxScore >= 20 && (maxScore - minScore === 2));
  };

  const calculateStandings = (group: Group) => {
    if (!group?.teams) return [];

    const standings: {
      [key: string]: { wins: number; pointsFor: number; pointsAgainst: number }
    } = {};

    // Inicializa as estatísticas para todas as duplas do grupo
    group.teams.forEach(team => {
      const teamName = `${team.atleta1}/${team.atleta2}`;
      standings[teamName] = { wins: 0, pointsFor: 0, pointsAgainst: 0 };
    });

    // Processa os confrontos do grupo
    matches.filter(m => m.rodada === group.name).forEach(match => {
      const { dupla1, dupla2 } = match.placar;

      if (standings[match.dupla1] && standings[match.dupla2]) {
        standings[match.dupla1].pointsFor += dupla1;
        standings[match.dupla1].pointsAgainst += dupla2;
        standings[match.dupla2].pointsFor += dupla2;
        standings[match.dupla2].pointsAgainst += dupla1;

        if (isValidScore(dupla1, dupla2)) {
          if (dupla1 > dupla2) {
            standings[match.dupla1].wins += 1;
          } else {
            standings[match.dupla2].wins += 1;
          }
        }
      } else {
        console.warn(`Confronto com dupla inválida: ${match.dupla1} vs ${match.dupla2}`);
      }
    });

    return Object.entries(standings)
      .map(([team, stats]) => ({
        team,
        wins: stats.wins,
        saldo: stats.pointsFor - stats.pointsAgainst,
        pa: stats.pointsAgainst > 0
          ? (stats.pointsFor / stats.pointsAgainst).toFixed(2)
          : '∞'
      }))
      .sort((a, b) => b.wins - a.wins || b.saldo - a.saldo || parseFloat(b.pa) - parseFloat(a.pa));
  };

  const allGroupMatchesCompleted = () => {
    return groups.every(group => {
      const groupMatches = matches.filter(m => m.rodada === group.name);
      return groupMatches.every(m => isValidScore(m.placar.dupla1, m.placar.dupla2));
    });
  };

  // As funções de geração de semifinais e finais permanecem no código,
  // mas como os botões foram removidos, elas não são acionadas pela interface.
  const generateSemifinals = () => {
    if (!allGroupMatchesCompleted()) {
      alert('Complete todos os jogos da fase de grupos primeiro!');
      return;
    }

    const validGroups = groups.filter(group => {
      const standings = calculateStandings(group);
      return standings.length >= 2;
    });

    if (validGroups.length < 2) {
      alert('É necessário pelo menos 2 grupos com 2 times cada para gerar as semifinais!');
      return;
    }

    const existingSemifinals = matches.filter(m => m.rodada === 'Semifinal');
    if (existingSemifinals.length > 0) {
      alert('As semifinais já foram geradas!');
      return;
    }

    const allStandings = validGroups.map(group => ({
      group: group.name,
      first: calculateStandings(group)[0]?.team,
      second: calculateStandings(group)[1]?.team
    }));

    const newMatches: Match[] = [];

    for (let i = 0; i < validGroups.length; i += 2) {
      const currentGroup = allStandings[i];
      const nextGroup = allStandings[i + 1];

      if (nextGroup) {
        if (currentGroup.first && nextGroup.second) {
          newMatches.push({
            id: crypto.randomUUID(),
            rodada: 'Semifinal',
            dupla1: currentGroup.first,
            dupla2: nextGroup.second,
            placar: { dupla1: 0, dupla2: 0 }
          });
        }

        if (nextGroup.first && currentGroup.second) {
          newMatches.push({
            id: crypto.randomUUID(),
            rodada: 'Semifinal',
            dupla1: nextGroup.first,
            dupla2: currentGroup.second,
            placar: { dupla1: 0, dupla2: 0 }
          });
        }
      }
    }

    onUpdateMatches([...matches, ...newMatches]);
  };

  const generateFinalMatches = () => {
    const semifinals = matches.filter(m => m.rodada === 'Semifinal');

    if (semifinals.some(m => !isValidScore(m.placar.dupla1, m.placar.dupla2))) {
      alert('Complete todas as semifinais primeiro!');
      return;
    }

    const existingFinal = matches.some(m => m.rodada === 'Final');
    const existingThirdPlace = matches.some(m => m.rodada === 'Terceiro Lugar');

    if (existingFinal && existingThirdPlace) {
      alert('A final e o terceiro lugar já foram gerados!');
      return;
    }

    const winners: string[] = [];
    const losers: string[] = [];

    semifinals.forEach(match => {
      if (match.placar.dupla1 > match.placar.dupla2) {
        winners.push(match.dupla1);
        losers.push(match.dupla2);
      } else {
        winners.push(match.dupla2);
        losers.push(match.dupla1);
      }
    });

    const newMatches: Match[] = [];

    if (!existingFinal) {
      newMatches.push({
        id: crypto.randomUUID(),
        rodada: 'Final',
        dupla1: winners[0],
        dupla2: winners[1],
        placar: { dupla1: 0, dupla2: 0 }
      });
    }

    if (!existingThirdPlace) {
      newMatches.push({
        id: crypto.randomUUID(),
        rodada: 'Terceiro Lugar',
        dupla1: losers[0],
        dupla2: losers[1],
        placar: { dupla1: 0, dupla2: 0 }
      });
    }

    onUpdateMatches([...matches, ...newMatches]);
  };

  return (
    <div className="p-4 sm:p-6">
      <div className="bg-white p-4 sm:p-6 rounded-lg shadow-md">
        {groups.map(group => (
          <div key={group.id} className="mb-6">
            <h3 className="font-bold mb-2 text-base sm:text-lg">Grupo {group.name}</h3>
            <div className="bg-gray-50 p-4 rounded-md">
              {calculateStandings(group).map(({ team, wins, saldo, pa }, index) => (
                <div
                  key={team}
                  className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-2 p-2 bg-white rounded shadow-sm"
                >
                  <div className="flex items-center gap-2 mb-1 sm:mb-0">
                    <span className="font-medium w-8">{index + 1}º</span>
                    <span className="font-semibold">{team}</span>
                  </div>
                  <div className="text-xs sm:text-sm text-gray-600 flex flex-wrap gap-1">
                    <span className="bg-green-100 px-2 py-1 rounded">{wins} V</span>
                    <span>|</span>
                    <span className="bg-blue-100 px-2 py-1 rounded">{saldo} SP</span>
                    <span>|</span>
                    <span className="bg-purple-100 px-2 py-1 rounded">{pa} PA</span>
                  </div>
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}


=== ./src\components\Swords.tsx ===
import React, { useState } from 'react';
import type { Match, Team } from '../types';

interface Props {
  teams: Team[];
  matches?: Match[];
  onUpdate: (matches: Match[]) => void;
}

export default function SwordsC({ teams, matches = [], onUpdate }: Props) {
  const [selectedMatch, setSelectedMatch] = useState<Match | null>(null);
  const [tempScore, setTempScore] = useState({ dupla1: 0, dupla2: 0 });

  const isValidScore = (score1: number, score2: number) => {
    const maxScore = Math.max(score1, score2);
    const minScore = Math.min(score1, score2);
    return (maxScore === 21 && minScore < 20) || (maxScore >= 20 && (maxScore - minScore === 2));
  };

  const handleScoreChange = (field: 'dupla1' | 'dupla2', value: string) => {
    setTempScore(prev => ({ ...prev, [field]: parseInt(value) || 0 }));
  };

  const saveScore = () => {
    if (selectedMatch && isValidScore(tempScore.dupla1, tempScore.dupla2)) {
      const updated = matches.map(m =>
        m.id === selectedMatch.id ? { ...m, placar: tempScore } : m
      );
      onUpdate(updated);
      setSelectedMatch(null);
    }
  };

  // Agrupa os times pelo atributo "grupo"
  const getGroups = () => {
    const groupsObj = teams.reduce((acc: { [key: string]: Team[] }, team) => {
      const groupName = team.grupo || 'Sem Grupo';
      if (!acc[groupName]) acc[groupName] = [];
      acc[groupName].push(team);
      return acc;
    }, {});
    return Object.entries(groupsObj).map(([name, teams]) => ({
      id: name,
      name,
      teams
    }));
  };

  // Gera os confrontos da fase de grupos
  const generateGroupMatches = () => {
    const groups = getGroups();
    const existingMatches = new Set(
      matches.map(m => `${m.rodada}|${m.dupla1}|${m.dupla2}`)
    );
    const newMatches: Match[] = [];
    groups.forEach(group => {
      group.teams.forEach((team1, i) => {
        for (let j = i + 1; j < group.teams.length; j++) {
          const team2 = group.teams[j];
          const dupla1 = `${team1.atleta1}/${team1.atleta2}`;
          const dupla2 = `${team2.atleta1}/${team2.atleta2}`;
          const matchKey = `${group.name}|${dupla1}|${dupla2}`;
          if (!existingMatches.has(matchKey)) {
            newMatches.push({
              id: crypto.randomUUID(),
              rodada: group.name,
              dupla1,
              dupla2,
              placar: { dupla1: 0, dupla2: 0 }
            });
          }
        }
      });
    });
    onUpdate([...matches, ...newMatches]);
  };

  // Calcula a classificação de cada grupo com base nos resultados
  const calculateStandings = (group: { id: string; name: string; teams: Team[] }) => {
    if (!group?.teams) return [];
    const standings: {
      [key: string]: { wins: number; pointsFor: number; pointsAgainst: number }
    } = {};
    group.teams.forEach(team => {
      const teamName = `${team.atleta1}/${team.atleta2}`;
      standings[teamName] = { wins: 0, pointsFor: 0, pointsAgainst: 0 };
    });
    matches.filter(m => m.rodada === group.name).forEach(match => {
      const { dupla1, dupla2 } = match.placar;
      if (standings[match.dupla1] && standings[match.dupla2]) {
        standings[match.dupla1].pointsFor += dupla1;
        standings[match.dupla1].pointsAgainst += dupla2;
        standings[match.dupla2].pointsFor += dupla2;
        standings[match.dupla2].pointsAgainst += dupla1;
        if (isValidScore(dupla1, dupla2)) {
          if (dupla1 > dupla2) {
            standings[match.dupla1].wins += 1;
          } else {
            standings[match.dupla2].wins += 1;
          }
        }
      }
    });
    return Object.entries(standings)
      .map(([team, stats]) => ({
        team,
        wins: stats.wins,
        saldo: stats.pointsFor - stats.pointsAgainst,
        pa: stats.pointsAgainst > 0
          ? (stats.pointsFor / stats.pointsAgainst).toFixed(2)
          : '∞'
      }))
      .sort((a, b) => b.wins - a.wins || b.saldo - a.saldo || parseFloat(b.pa) - parseFloat(a.pa));
  };

  // Verifica se todos os confrontos dos grupos foram concluídos (placar válido)
  const allGroupMatchesCompleted = (groups: { id: string; name: string; teams: Team[] }[]) => {
    return groups.every(group => {
      const groupMatches = matches.filter(m => m.rodada === group.name);
      return groupMatches.every(m => isValidScore(m.placar.dupla1, m.placar.dupla2));
    });
  };

  // Gera as semifinais com base nos melhores de cada grupo
  const generateSemifinais = () => {
    const groups = getGroups();
    if (!allGroupMatchesCompleted(groups)) {
      alert('Complete todos os jogos da fase de grupos primeiro!');
      return;
    }
    const validGroups = groups.filter(group => calculateStandings(group).length >= 2);
    if (validGroups.length < 2) {
      alert('É necessário pelo menos 2 grupos com 2 times cada para gerar as semifinais!');
      return;
    }
    if (matches.some(m => m.rodada === 'Semifinal')) {
      alert('As semifinais já foram geradas!');
      return;
    }
    const allStandings = validGroups.map(group => ({
      group: group.name,
      first: calculateStandings(group)[0]?.team,
      second: calculateStandings(group)[1]?.team
    }));
    const newMatches: Match[] = [];
    for (let i = 0; i < validGroups.length; i += 2) {
      const currentGroup = allStandings[i];
      const nextGroup = allStandings[i + 1];
      if (nextGroup) {
        if (currentGroup.first && nextGroup.second) {
          newMatches.push({
            id: crypto.randomUUID(),
            rodada: 'Semifinal',
            dupla1: currentGroup.first,
            dupla2: nextGroup.second,
            placar: { dupla1: 0, dupla2: 0 }
          });
        }
        if (nextGroup.first && currentGroup.second) {
          newMatches.push({
            id: crypto.randomUUID(),
            rodada: 'Semifinal',
            dupla1: nextGroup.first,
            dupla2: currentGroup.second,
            placar: { dupla1: 0, dupla2: 0 }
          });
        }
      }
    }
    onUpdate([...matches, ...newMatches]);
  };

  // Gera a Final e o confronto para o 3º lugar a partir dos resultados das semifinais
  const generateFinalMatches = () => {
    const semifinals = matches.filter(m => m.rodada === 'Semifinal');

    // Verifica se as semifinais estão definidas (exige pelo menos 2 partidas)
    if (semifinals.length < 2) {
      alert('As semifinais ainda não foram definidas!');
      return;
    }

    // Verifica se todas as semifinais possuem placar válido (ou seja, já há um vencedor e um perdedor)
    if (semifinals.some(m => !isValidScore(m.placar.dupla1, m.placar.dupla2))) {
      alert('Complete todas as semifinais primeiro!');
      return;
    }

    if (matches.some(m => m.rodada === 'Final')) {
      alert('Terceiro lugar e a final já foram geradas!');
      return;
    }

    const winners = [];
    const losers = [];
    semifinals.forEach(match => {
      if (match.placar.dupla1 > match.placar.dupla2) {
        winners.push(match.dupla1);
        losers.push(match.dupla2);
      } else {
        winners.push(match.dupla2);
        losers.push(match.dupla1);
      }
    });

    // Atualiza confrontos de Final e Terceiro Lugar se já existirem, ou cria novos
    const updatedMatches = matches.map(m => {
      if (m.rodada === 'Final') {
        return { ...m, dupla1: winners[0], dupla2: winners[1], placar: m.placar || { dupla1: 0, dupla2: 0 } };
      }
      if (m.rodada === 'Terceiro Lugar') {
        return { ...m, dupla1: losers[0], dupla2: losers[1], placar: m.placar || { dupla1: 0, dupla2: 0 } };
      }
      return m;
    });

    const newMatches = [];
    if (!matches.some(m => m.rodada === 'Final')) {
      newMatches.push({
        id: crypto.randomUUID(),
        rodada: 'Final',
        dupla1: winners[0],
        dupla2: winners[1],
        placar: { dupla1: 0, dupla2: 0 }
      });
    }
    if (!matches.some(m => m.rodada === 'Terceiro Lugar')) {
      newMatches.push({
        id: crypto.randomUUID(),
        rodada: 'Terceiro Lugar',
        dupla1: losers[0],
        dupla2: losers[1],
        placar: { dupla1: 0, dupla2: 0 }
      });
    }

    onUpdate([...updatedMatches, ...newMatches]);
  };


  return (
    <div className="p-6">
      <div className="bg-white p-6 rounded-lg shadow-md">
        {/* Seção com os botões de "Gerar" */}
        <div className="flex flex-wrap gap-4 mb-6">
          <button
            onClick={generateGroupMatches}
            className="w-full sm:w-auto px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 text-xs sm:text-base"
          >
            Gerar Confrontos dos Grupos
          </button>
          <button
            onClick={generateSemifinais}
            className="w-full sm:w-auto px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 text-xs sm:text-base"
          >
            Gerar Semifinais
          </button>
          <button
            onClick={generateFinalMatches}
            className="w-full sm:w-auto px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 text-xs sm:text-base"
          >
            Gerar Final e 3º Lugar
          </button>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* Partidas dos Grupos */}
          <div>
            <h3 className="text-lg font-bold mb-4">Partidas dos Grupos</h3>
            {[...new Set(matches?.map(m => m.rodada))]
              .filter(rodada => !['Semifinal', 'Terceiro Lugar', 'Final'].includes(rodada))
              .map(group => (
                <div key={group} className="mb-6">
                  <h4 className="font-medium mb-2">{group}</h4>
                  {(matches || []).filter(m => m.rodada === group).map(match => (
                    <div
                      key={match.id}
                      className="bg-gray-50 p-3 rounded-md mb-2 cursor-pointer hover:bg-gray-100"
                      onClick={() => {
                        setSelectedMatch(match);
                        setTempScore(match.placar);
                      }}
                    >
                      <div className="flex justify-between items-center">
                        <span className="flex-1 text-right">{match.dupla1}</span>
                        <span className="mx-3 font-bold">vs</span>
                        <span className="flex-1 text-left">{match.dupla2}</span>
                      </div>
                      {match.placar.dupla1 + match.placar.dupla2 > 0 && (
                        <div className={`text-center mt-2 font-medium ${isValidScore(match.placar.dupla1, match.placar.dupla2)
                          ? 'text-green-600'
                          : 'text-red-600'
                          }`}>
                          {match.placar.dupla1} - {match.placar.dupla2}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              ))}
          </div>


          {/* Fases Eliminatórias */}
          <div>
            <h3 className="text-lg font-bold mb-4">Fases Eliminatórias</h3>
            {['Semifinal', 'Terceiro Lugar', 'Final'].map(stage => (
              <div key={stage} className="mb-6">
                <h4 className="font-medium mb-2">{stage}</h4>
                {(matches || []).filter(m => m.rodada === stage).map(match => (
                  <div
                    key={match.id}
                    className="bg-gray-50 p-3 rounded-md mb-2 cursor-pointer hover:bg-gray-100"
                    onClick={() => {
                      setSelectedMatch(match);
                      setTempScore(match.placar);
                    }}
                  >
                    <div className="flex justify-between items-center">
                      <span>{match.dupla1}</span>
                      <span className="mx-2">vs</span>
                      <span>{match.dupla2}</span>
                    </div>
                    {match.placar.dupla1 + match.placar.dupla2 > 0 && (
                      <div className={`text-center mt-2 font-medium ${isValidScore(match.placar.dupla1, match.placar.dupla2)
                        ? 'text-green-600'
                        : 'text-red-600'
                        }`}>
                        {match.placar.dupla1} - {match.placar.dupla2}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            ))}
          </div>
        </div>

        {/* Modal de Edição */}
        {selectedMatch && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
            <div className="bg-white p-6 rounded-lg shadow-lg w-96">
              <h2 className="text-xl font-bold mb-4">Editar Placar</h2>
              <div className="flex items-center justify-center gap-4 mb-4">
                <div className="text-center">
                  <input
                    type="number"
                    value={tempScore.dupla1}
                    onChange={(e) => handleScoreChange('dupla1', e.target.value)}
                    className="w-20 text-center text-xl p-2 border rounded-md"
                    min="0"
                  />
                  <div className="mt-2 text-sm text-gray-600">{selectedMatch.dupla1}</div>
                </div>
                <span className="text-2xl font-bold">x</span>
                <div className="text-center">
                  <input
                    type="number"
                    value={tempScore.dupla2}
                    onChange={(e) => handleScoreChange('dupla2', e.target.value)}
                    className="w-20 text-center text-xl p-2 border rounded-md"
                    min="0"
                  />
                  <div className="mt-2 text-sm text-gray-600">{selectedMatch.dupla2}</div>
                </div>
              </div>
              <div className="flex gap-2">
                <button
                  onClick={saveScore}
                  className="flex-1 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700"
                >
                  Salvar
                </button>
                <button
                  onClick={() => setSelectedMatch(null)}
                  className="flex-1 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300"
                >
                  Cancelar
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}


=== ./src\components\TeamFormation.tsx ===
import React, { useState } from 'react';
import type { Athlete, Team } from '../types';

interface Props {
  athletes: Athlete[];
  teams: Team[];
  onUpdate: (teams: Team[]) => void;
}

export default function TeamFormation({ athletes, teams, onUpdate }: Props) {
  const [athlete1, setAthlete1] = useState('');
  const [athlete2, setAthlete2] = useState('');
  const [grupo, setGrupo] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!athlete1 || !athlete2) return;

    const isDuplicate = teams.some(team =>
      (team.atleta1 === athlete1 && team.atleta2 === athlete2) ||
      (team.atleta1 === athlete2 && team.atleta2 === athlete1)
    );

    if (isDuplicate) {
      alert('Dupla já cadastrada!');
      return;
    }

    const newTeam: Team = {
      id: teams.length + 1,
      atleta1: athlete1,
      atleta2: athlete2,
      grupo,
    };

    onUpdate([...teams, newTeam]);
    setAthlete1('');
    setAthlete2('');
    setGrupo('');
  };

  // Função para remover uma dupla
  const handleRemoveTeam = (teamId: number) => {
    const updatedTeams = teams.filter(team => team.id !== teamId);
    onUpdate(updatedTeams);
  };

  return (
    <div>
      <h2 className="text-2xl font-bold mb-6">Formação de Duplas</h2>

      <form onSubmit={handleSubmit} className="mb-8">
        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Atleta 1
            </label>
            <select
              value={athlete1}
              onChange={(e) => setAthlete1(e.target.value)}
              className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            >
              <option value="">Selecione um atleta</option>
              {athletes.map((athlete) => (
                <option key={athlete.id} value={athlete.nome}>
                  {athlete.nome}
                </option>
              ))}
            </select>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Atleta 2
            </label>
            <select
              value={athlete2}
              onChange={(e) => setAthlete2(e.target.value)}
              className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            >
              <option value="">Selecione um atleta</option>
              {athletes
                .filter((athlete) => athlete.nome !== athlete1)
                .map((athlete) => (
                  <option key={athlete.id} value={athlete.nome}>
                    {athlete.nome}
                  </option>
                ))}
            </select>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Grupo
            </label>
            <select
              value={grupo}
              onChange={(e) => setGrupo(e.target.value)}
              className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            >
              <option value="">Selecione um grupo</option>
              <option value="A">Grupo A</option>
              <option value="B">Grupo B</option>
              <option value="C">Grupo C</option>
              <option value="D">Grupo D</option>
            </select>
          </div>
        </div>

        <button
          type="submit"
          className="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
        >
          Criar Dupla
        </button>
      </form>

      <div className="bg-gray-50 rounded-lg p-4 mt-8">
        <h3 className="text-lg font-semibold mb-4">Duplas Cadastradas</h3>
        {teams.length === 0 ? (
          <p className="text-gray-500">Nenhuma dupla cadastrada</p>
        ) : (
          <ul className="space-y-2">
            {teams.map((team) => (
              <li
                key={team.id}
                className="flex items-center justify-between bg-white p-3 rounded-md shadow-sm"
              >
                <div className="flex-1">
                  <span className="font-medium">{team.atleta1}</span> e{' '}
                  <span className="font-medium">{team.atleta2}</span>
                  {team.grupo && (
                    <span className="ml-4 text-gray-600">
                      (Grupo: {team.grupo})
                    </span>
                  )}
                </div>
                <div className="flex items-center gap-4">
                  <button
                    onClick={() => handleRemoveTeam(team.id)}
                    className="text-red-600 hover:text-red-800 font-medium"
                    title="Remover dupla"
                  >
                    Remover
                  </button>
                </div>
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>
  );
}

=== ./src\components\VotingSystem.tsx ===
import React, { useState } from 'react';
import type { Athlete, Match, RoundVotes } from '../types';

interface Props {
  athletes: Athlete[];
  matches: Match[];
  votes: RoundVotes;
  onUpdate: (votes: RoundVotes) => void;
}

export default function VotingSystem({ athletes, matches, votes, onUpdate }: Props) {
  const [selectedMatchId, setSelectedMatchId] = useState('');
  const [voter, setVoter] = useState('');
  const [votedFor, setVotedFor] = useState('');

  // Obter atletas do confronto selecionado
  const getMatchAthletes = () => {
    if (!selectedMatchId) return [];

    const match = matches.find(m => m.id === selectedMatchId);
    if (!match) return [];

    // Extrair nomes dos atletas das duplas
    const allPlayers = [
      ...match.dupla1.split('/'),
      ...match.dupla2.split('/')
    ];

    return athletes.filter(athlete =>
      allPlayers.includes(athlete.nome)
    );
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!selectedMatchId || !voter || !votedFor) return;

    const match = matches.find(m => m.id === selectedMatchId);
    if (!match) return;

    // Utiliza o id do confronto como chave
    const matchVotes = votes[selectedMatchId] || [];
    const newVote = { votante: voter, voto: votedFor };

    onUpdate({
      ...votes,
      [selectedMatchId]: [...matchVotes, newVote],
    });

    setVoter('');
    setVotedFor('');
  };

  return (
    <div>
      <h2 className="text-2xl font-bold mb-6">Sistema de Votação</h2>

      <form onSubmit={handleSubmit} className="mb-8">
        <div className="grid grid-cols-1 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Confronto
            </label>
            <select
              value={selectedMatchId}
              onChange={(e) => setSelectedMatchId(e.target.value)}
              className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            >
              <option value="">Selecione um confronto</option>
              {matches.map((match) => (
                <option key={match.id} value={match.id}>
                  {match.dupla1} vs {match.dupla2} ({match.rodada})
                </option>
              ))}
            </select>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Votante
            </label>
            <select
              value={voter}
              onChange={(e) => setVoter(e.target.value)}
              className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            >
              <option value="">Selecione o votante</option>
              {athletes.map((athlete) => (
                <option key={athlete.id} value={athlete.nome}>
                  {athlete.nome}
                </option>
              ))}
            </select>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Voto para Melhor Atleta
            </label>
            <select
              value={votedFor}
              onChange={(e) => setVotedFor(e.target.value)}
              className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
              disabled={!selectedMatchId}
            >
              <option value="">Selecione o atleta</option>
              {getMatchAthletes()
                .filter((athlete) => athlete.nome !== voter)
                .map((athlete) => (
                  <option key={athlete.id} value={athlete.nome}>
                    {athlete.nome}
                  </option>
                ))}
            </select>
          </div>
        </div>

        <button
          type="submit"
          className="mt-4 w-full px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          disabled={!selectedMatchId || !voter || !votedFor}
        >
          Registrar Voto
        </button>
      </form>

      <div className="bg-gray-50 rounded-lg p-4">
        <h3 className="text-lg font-semibold mb-4">Votos Registrados</h3>
        {Object.keys(votes).length === 0 ? (
          <p className="text-gray-500">Nenhum voto registrado</p>
        ) : (
          <div className="space-y-6">
            {Object.entries(votes).map(([matchId, matchVotes]) => {
              const match = matches.find(m => m.id === matchId);
              return (
                <div key={matchId} className="bg-white p-4 rounded-md shadow-sm">
                  <h4 className="font-medium mb-3">
                    {match ? `${match.dupla1} vs ${match.dupla2} (${match.rodada})` : matchId}
                  </h4>
                  <ul className="space-y-2">
                    {matchVotes.map((vote, index) => (
                      <li
                        key={`${matchId}-${index}`}
                        className="flex justify-between items-center text-sm"
                      >
                        <span className="text-gray-600">{vote.votante}</span>
                        <span className="font-medium">votou em</span>
                        <span className="text-indigo-600">{vote.voto}</span>
                      </li>
                    ))}
                  </ul>
                </div>
              );
            })}
          </div>
        )}
      </div>
    </div>
  );
}


=== ./src\services\jsonbin.ts ===
import axios from 'axios';
import type { Database } from '../types';
import { initialData } from '../types.ts';

const JSONBIN_API_KEY = '$2a$10$2EXYkBLG9hlyY8HZN7ABKOVwtBKpIsi86FZ72iU8.AJ4SFD92D3Wy'; // Replace with your JSONBin.io API key
const BIN_ID = '67a12c15e41b4d34e4838ee6'; // Replace with your bin ID
const BASE_URL = 'https://api.jsonbin.io/v3/b';

const api = axios.create({
  baseURL: BASE_URL,
  headers: {
    'X-Master-Key': JSONBIN_API_KEY,
    'Content-Type': 'application/json',
  },
});

export async function fetchData(): Promise<Database> {
  try {
    const response = await api.get(`/${BIN_ID}/latest`);
    return {
      ...initialData,
      ...response.data.record,
      atletas: response.data.record.atletas || [],
      duplas: response.data.record.duplas || [],
      confrontos: response.data.record.confrontos || [],
      grupos: response.data.record.grupos || []
    };
  } catch (error) {
    console.error('Error fetching data:', error);
    throw new Error(`Failed to fetch data: ${error.message}`);
  }
}

export async function updateData(data: Database): Promise<void> {
  try {
    await api.put(`/${BIN_ID}`, data);
  } catch (error) {
    console.error('Error updating data:', error);
    throw new Error(`Failed to update data: ${error.message}`);
  }
}

