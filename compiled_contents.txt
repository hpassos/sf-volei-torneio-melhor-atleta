=== ./src\App.tsx ===
import React, { useState, useEffect } from 'react';
import { Trophy, Users, Swords, Vote, BarChart3, LayoutGrid } from 'lucide-react';
import AthleteRegistration from './components/AthleteRegistration';
import TeamFormation from './components/TeamFormation';
import SwordsC from './components/Swords';
import VotingSystem from './components/VotingSystem';
import Dashboard from './components/Dashboard';
import GroupStage from './components/GroupStage';
import { fetchData, updateData } from './services/jsonbin';
import type { Database } from './types';
import { initialData } from './types';



function App() {
  const [activeTab, setActiveTab] = useState('dashboard');
  const [data, setData] = useState<Database>(initialData);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      const fetchedData = await fetchData();
      setData(fetchedData);
      setError(null);
    } catch (err) {
      setError('Erro ao carregar dados. Por favor, tente novamente.');
    } finally {
      setLoading(false);
    }
  };

  const handleDataUpdate = async (newData: Database) => {
    try {
      setLoading(true);
      await updateData(newData);
      setData(newData);
      setError(null);
    } catch (err) {
      setError('Erro ao salvar dados. Por favor, tente novamente.');
    } finally {
      setLoading(false);
    }
  };

  const tabs = [
    { id: 'dashboard', label: 'Dashboard', icon: BarChart3 },
    { id: 'athletes', label: 'Cadastro de Atletas', icon: Users },
    { id: 'teams', label: 'Formação de Duplas', icon: Trophy },
    { id: 'groups', label: 'Fase de Grupos', icon: LayoutGrid },
    { id: 'matches', label: 'Confrontos', icon: Swords },
    { id: 'voting', label: 'Votação', icon: Vote },
  ];

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto"></div>
          <p className="mt-4 text-gray-600">Carregando...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-indigo-600 text-white py-6 shadow-lg">
        <div className="container mx-auto px-4">
          <h1 className="text-3xl font-bold">Sistema de Votação Entre Atletas</h1>
        </div>
      </header>

      <nav className="bg-white shadow-md">
        <div className="container mx-auto px-4">
          <div className="flex space-x-1">
            {tabs.map(({ id, label, icon: Icon }) => (
              <button
                key={id}
                onClick={() => setActiveTab(id)}
                className={`flex items-center space-x-2 px-4 py-3 font-medium transition-colors ${activeTab === id
                  ? 'border-b-2 border-indigo-600 text-indigo-600'
                  : 'text-gray-600 hover:text-indigo-600'
                  }`}
              >
                <Icon className="h-5 w-5" />
                <span>{label}</span>
              </button>
            ))}
          </div>
        </div>
      </nav>

      <main className="container mx-auto px-4 py-8">
        {error && (
          <div className="mb-4 p-4 bg-red-100 text-red-700 rounded-lg">
            {error}
          </div>
        )}

        <div className="bg-white rounded-lg shadow-md p-6">
          {activeTab === 'dashboard' && <Dashboard data={data} />}
          {activeTab === 'athletes' && (
            <AthleteRegistration
              athletes={data.atletas}
              onUpdate={(athletes) => handleDataUpdate({ ...data, atletas: athletes })}
            />
          )}
          {activeTab === 'teams' && (
            <TeamFormation
              athletes={data.atletas}
              teams={data.duplas}
              onUpdate={(teams) => handleDataUpdate({ ...data, duplas: teams })}
            />
          )}
          {activeTab === 'matches' && (
            <SwordsC
              teams={data.duplas}
              matches={data.confrontos}
              onUpdate={(matches) => handleDataUpdate({ ...data, confrontos: matches })}
            />
          )}
          {activeTab === 'voting' && (
            <VotingSystem
              athletes={data.atletas}
              matches={data.confrontos}
              votes={data.votacoes}
              onUpdate={(votes) => handleDataUpdate({ ...data, votacoes: votes })}
            />
          )}
          {activeTab === 'groups' && (
            <GroupStage
              teams={data.duplas}
              matches={data.confrontos}
              onUpdateMatches={(matches) => handleDataUpdate({ ...data, confrontos: matches })}
            />
          )}
        </div>
      </main>
    </div>
  );
}

export default App;


=== ./src\index.css ===
@tailwind base;
@tailwind components;
@tailwind utilities;


=== ./src\main.tsx ===
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import App from './App.tsx';
import './index.css';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>
);


=== ./src\types.ts ===
export interface Athlete {
  id: string;
  nome: string;
}

export interface Team {
  id: number;
  atleta1: string;
  atleta2: string;
  grupo: string;
}

export interface Match {
  id: string;
  rodada: string;
  dupla1: string;
  dupla2: string;
  placar: {
    dupla1: number;
    dupla2: number;
  };
}

export interface Vote {
  votante: string;
  voto: string;
}

export interface RoundVotes {
  [key: string]: Vote[];
}

export interface Database {
  atletas: Athlete[];
  duplas: Team[];
  confrontos: Match[];
  votacoes: RoundVotes;
  grupos: Group[];
}

export const initialData: Database = {
  atletas: [],
  duplas: [],
  confrontos: [],
  votacoes: {},
  grupos: [],
};

=== ./src\vite-env.d.ts ===
/// <reference types="vite/client" />


=== ./src\components\AthleteRegistration.tsx ===
import React, { useState } from 'react';
import type { Athlete } from '../types';


interface Props {
  athletes: Athlete[];
  onUpdate: (athletes: Athlete[]) => void;
}

const generateId = () => {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  // Fallback para um ID simples (não é um UUID real)
  return Math.random().toString(36).substring(2, 9);
};

export default function AthleteRegistration({ athletes, onUpdate }: Props) {
  const [name, setName] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim()) return;

    const isDuplicate = athletes.some(athlete => athlete.nome === name.trim());
    if (isDuplicate) {
      alert('Atleta já cadastrado!');
      return;
    }

    const newAthlete: Athlete = {
      id: generateId(),
      nome: name.trim(),
    };

    onUpdate([...athletes, newAthlete]);
    setName('');
  };

  const handleDelete = (athleteId: string) => {
    const updatedAthletes = athletes.filter(athlete => athlete.id !== athleteId);
    onUpdate(updatedAthletes);
  };

  return (
    <div>
      <h2 className="text-2xl font-bold mb-6">Cadastro de Atletas</h2>

      <form onSubmit={handleSubmit} className="mb-8">
        <div className="flex gap-4">
          <input
            type="text"
            value={name}
            onChange={(e) => setName(e.target.value)}
            placeholder="Nome do atleta"
            className="flex-1 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
          />
          <button
            type="submit"
            className="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          >
            Adicionar Atleta
          </button>
        </div>
      </form>

      <div className="bg-gray-50 rounded-lg p-4">
        <h3 className="text-lg font-semibold mb-4">Atletas Cadastrados</h3>
        {athletes.length === 0 ? (
          <p className="text-gray-500">Nenhum atleta cadastrado</p>
        ) : (
          <ul className="space-y-2">
            {athletes.map((athlete) => (
              <li
                key={athlete.id}
                className="flex items-center justify-between bg-white p-3 rounded-md shadow-sm"
              >
                <span>{athlete.nome}</span>
                <button
                  onClick={() => handleDelete(athlete.id)}
                  className="text-red-600 hover:text-red-800 font-medium"
                  title="Remover atleta"
                >
                  Remover
                </button>
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>
  );
}

=== ./src\components\Dashboard.tsx ===
import React, { useMemo } from 'react';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  PieChart,
  Pie,
  Cell,
} from 'recharts';

import type { Database } from '../types';

interface Props {
  data: Database;
}

const COLORS = ['#4F46E5', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6'];

export default function Dashboard({ data }: Props) {
  const voteStats = useMemo(() => {
    const stats: Record<string, number> = {};

    Object.values(data.votacoes).forEach(roundVotes => {
      roundVotes.forEach(vote => {
        stats[vote.voto] = (stats[vote.voto] || 0) + 1;
      });
    });

    return Object.entries(stats)
      .map(([name, votes]) => ({ name, votes }))
      .sort((a, b) => b.votes - a.votes); // Ordena do mais votado para o menos
  }, [data.votacoes]);

  const matchStats = useMemo(() => {
    const stats: Record<string, { wins: number; totalGames: number }> = {};

    data.confrontos.forEach(match => {
      const winner = match.placar.dupla1 > match.placar.dupla2 ? match.dupla1 : match.dupla2;
      const teams = [match.dupla1, match.dupla2];

      teams.forEach(team => {
        if (!stats[team]) {
          stats[team] = { wins: 0, totalGames: 0 };
        }
        stats[team].totalGames++;
        if (team === winner) {
          stats[team].wins++;
        }
      });
    });

    return Object.entries(stats).map(([team, { wins, totalGames }]) => ({
      team,
      winRate: (wins / totalGames) * 100,
    }));
  }, [data.confrontos]);

  return (
    <div>
      <h2 className="text-2xl font-bold mb-6">Dashboard</h2>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
        <div className="bg-white p-6 rounded-lg shadow-md">
          <h3 className="text-lg font-semibold mb-4">Atletas Mais Votados</h3>
          <div className="flex justify-center">
            <BarChart
              width={500}
              height={300}
              data={voteStats}
              margin={{ top: 5, right: 30, left: 20, bottom: 5 }}
            >
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis
                dataKey="name"
                angle={-45}
                textAnchor="end"
                interval={0}
                height={70}
              />
              <YAxis />
              <Tooltip />
              <Legend />
              <Bar
                dataKey="votes"
                name="Votos"
                fill="#4F46E5"
                barSize={20}
              />
            </BarChart>
          </div>


          <div className="mt-6 space-y-3">
            {voteStats.slice(0, 3).map((athlete, index) => (
              <div
                key={athlete.name}
                className="flex items-center justify-between p-3 bg-indigo-50 rounded-lg"
              >
                <div className="flex items-center space-x-2">
                  <span className="font-bold text-indigo-600">
                    #{index + 1}
                  </span>
                  <span className="font-medium">{athlete.name}</span>
                </div>
                <span className="bg-indigo-600 text-white px-3 py-1 rounded-full text-sm">
                  {athlete.votes} votos
                </span>
              </div>
            ))}
          </div>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
          <div className="bg-white p-6 rounded-lg shadow-md">
            <h3 className="text-lg font-semibold mb-4">Votos por Atleta</h3>
            <div className="flex justify-center">
              <PieChart width={400} height={300}>
                <Pie
                  data={voteStats}
                  dataKey="votes"
                  nameKey="name"
                  cx="50%"
                  cy="50%"
                  outerRadius={100}
                  label
                >
                  {voteStats.map((_, index) => (
                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                  ))}
                </Pie>
                <Tooltip />
                <Legend />
              </PieChart>
            </div>
          </div>

          <div className="bg-white p-6 rounded-lg shadow-md">
            <h3 className="text-lg font-semibold mb-4">Taxa de Vitória por Dupla</h3>
            <div className="flex justify-center">
              <BarChart width={400} height={300} data={matchStats}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="team" angle={-45} textAnchor="end" height={100} />
                <YAxis label={{ value: 'Taxa de Vitória (%)', angle: -90, position: 'insideLeft' }} />
                <Tooltip />
                <Bar dataKey="winRate" fill="#4F46E5" />
              </BarChart>
            </div>
          </div>

          <div className="bg-white p-6 rounded-lg shadow-md md:col-span-2">
            <h3 className="text-lg font-semibold mb-4">Estatísticas Gerais</h3>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
              <div className="bg-indigo-50 p-4 rounded-lg">
                <p className="text-sm text-indigo-600 mb-1">Total de Atletas</p>
                <p className="text-2xl font-bold text-indigo-900">{data.atletas.length}</p>
              </div>
              <div className="bg-emerald-50 p-4 rounded-lg">
                <p className="text-sm text-emerald-600 mb-1">Total de Duplas</p>
                <p className="text-2xl font-bold text-emerald-900">{data.duplas.length}</p>
              </div>
              <div className="bg-amber-50 p-4 rounded-lg">
                <p className="text-sm text-amber-600 mb-1">Partidas Realizadas</p>
                <p className="text-2xl font-bold text-amber-900">{data.confrontos.length}</p>
              </div>
              <div className="bg-purple-50 p-4 rounded-lg">
                <p className="text-sm text-purple-600 mb-1">Total de Votos</p>
                <p className="text-2xl font-bold text-purple-900">
                  {Object.values(data.votacoes).flat().reduce((acc, curr) => acc + curr.length, 0)}
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

=== ./src\components\GroupStage.tsx ===
import React, { useState, useEffect } from 'react';
import type { Team, Match, Group } from '../types';

interface Props {
  teams: Team[];
  matches: Match[];
  onUpdateMatches: (matches: Match[]) => void;
}

export default function GroupStage({ teams, matches, onUpdateMatches }: Props) {
  const [groups, setGroups] = useState<Group[]>([]);
  const [selectedMatch, setSelectedMatch] = useState<Match | null>(null);
  const [tempScore, setTempScore] = useState({ dupla1: 0, dupla2: 0 });

  useEffect(() => {
    const grouped = teams.reduce((acc: { [key: string]: Team[] }, team) => {
      const groupName = team.grupo || 'Sem Grupo';
      if (!acc[groupName]) acc[groupName] = [];
      acc[groupName].push(team);
      return acc;
    }, {});

    const formattedGroups = Object.entries(grouped).map(([name, teams]) => ({
      id: name,
      name,
      teams
    }));

    setGroups(formattedGroups);
  }, [teams]);

  const isValidScore = (score1: number, score2: number) => {
    const maxScore = Math.max(score1, score2);
    const minScore = Math.min(score1, score2);
    return (maxScore === 21 && minScore < 20) || (maxScore >= 20 && (maxScore - minScore === 2));
  };

  const calculateStandings = (group: Group) => {
    if (!group?.teams) return [];

    const standings: {
      [key: string]: { wins: number; pointsFor: number; pointsAgainst: number }
    } = {};

    group.teams.forEach(team => {
      const teamName = `${team.atleta1}/${team.atleta2}`;
      standings[teamName] = { wins: 0, pointsFor: 0, pointsAgainst: 0 };
    });

    matches.filter(m => m.rodada === group.name).forEach(match => {
      const { dupla1, dupla2 } = match.placar;

      standings[match.dupla1].pointsFor += dupla1;
      standings[match.dupla1].pointsAgainst += dupla2;
      standings[match.dupla2].pointsFor += dupla2;
      standings[match.dupla2].pointsAgainst += dupla1;

      if (isValidScore(dupla1, dupla2)) {
        if (dupla1 > dupla2) {
          standings[match.dupla1].wins += 1;
        } else {
          standings[match.dupla2].wins += 1;
        }
      }
    });

    return Object.entries(standings).map(([team, stats]) => ({
      team,
      wins: stats.wins,
      saldo: stats.pointsFor - stats.pointsAgainst,
      pa: stats.pointsAgainst > 0
        ? (stats.pointsFor / stats.pointsAgainst).toFixed(2)
        : '∞'
    })).sort((a, b) => b.wins - a.wins || b.saldo - a.saldo || parseFloat(b.pa) - parseFloat(a.pa));
  };

  const allGroupMatchesCompleted = () => {
    return groups.every(group => {
      const groupMatches = matches.filter(m => m.rodada === group.name);
      return groupMatches.every(m => isValidScore(m.placar.dupla1, m.placar.dupla2));
    });
  };

  const generateSemifinals = () => {
    if (!allGroupMatchesCompleted()) {
      alert('Complete todos os jogos da fase de grupos primeiro!');
      return;
    }

    const validGroups = groups.filter(group => {
      const standings = calculateStandings(group);
      return standings.length >= 2; // Pelo menos 2 times no grupo
    });

    if (validGroups.length < 2) {
      alert('É necessário pelo menos 2 grupos com 2 times cada para gerar as semifinais!');
      return;
    }

    // Verificar se as semifinais já foram geradas
    const existingSemifinals = matches.filter(m => m.rodada === 'Semifinal');
    if (existingSemifinals.length > 0) {
      alert('As semifinais já foram geradas!');
      return;
    }

    // Coletar os melhores de cada grupo
    const allStandings = validGroups.map(group => ({
      group: group.name,
      first: calculateStandings(group)[0]?.team,
      second: calculateStandings(group)[1]?.team
    }));

    const newMatches: Match[] = [];

    // Gerar confrontos cruzados entre grupos
    for (let i = 0; i < validGroups.length; i += 2) {
      const currentGroup = allStandings[i];
      const nextGroup = allStandings[i + 1];

      if (nextGroup) { // Só cria se tiver um grupo par para cruzar
        // 1º do grupo atual vs 2º do próximo grupo
        if (currentGroup.first && nextGroup.second) {
          newMatches.push({
            id: crypto.randomUUID(),
            rodada: 'Semifinal',
            dupla1: currentGroup.first,
            dupla2: nextGroup.second,
            placar: { dupla1: 0, dupla2: 0 }
          });
        }

        // 1º do próximo grupo vs 2º do grupo atual
        if (nextGroup.first && currentGroup.second) {
          newMatches.push({
            id: crypto.randomUUID(),
            rodada: 'Semifinal',
            dupla1: nextGroup.first,
            dupla2: currentGroup.second,
            placar: { dupla1: 0, dupla2: 0 }
          });
        }
      }
    }

    onUpdateMatches([...matches, ...newMatches]);
  };

  const generateFinalMatches = () => {
    const semifinals = matches.filter(m => m.rodada === 'Semifinal');

    if (semifinals.some(m => !isValidScore(m.placar.dupla1, m.placar.dupla2))) {
      alert('Complete todas as semifinais primeiro!');
      return;
    }

    // Verificar se a final e terceiro lugar já foram gerados
    const existingFinal = matches.some(m => m.rodada === 'Final');
    const existingThirdPlace = matches.some(m => m.rodada === 'Terceiro Lugar');

    if (existingFinal && existingThirdPlace) {
      alert('A final e o terceiro lugar já foram gerados!');
      return;
    }

    const winners: string[] = [];
    const losers: string[] = [];

    semifinals.forEach(match => {
      if (match.placar.dupla1 > match.placar.dupla2) {
        winners.push(match.dupla1);
        losers.push(match.dupla2);
      } else {
        winners.push(match.dupla2);
        losers.push(match.dupla1);
      }
    });

    const newMatches: Match[] = [];

    if (!existingFinal) {
      newMatches.push({
        id: crypto.randomUUID(),
        rodada: 'Final',
        dupla1: winners[0],
        dupla2: winners[1],
        placar: { dupla1: 0, dupla2: 0 }
      });
    }

    if (!existingThirdPlace) {
      newMatches.push({
        id: crypto.randomUUID(),
        rodada: 'Terceiro Lugar',
        dupla1: losers[0],
        dupla2: losers[1],
        placar: { dupla1: 0, dupla2: 0 }
      });
    }

    onUpdateMatches([...matches, ...newMatches]);
  };

  return (
    <div className="p-6">
      <div className="bg-white p-6 rounded-lg shadow-md">
        <div className="flex gap-4 mb-6">
          <button
            onClick={() => {
              const existingMatches = new Set(
                matches.map(m => `${m.rodada}|${m.dupla1}|${m.dupla2}`)
              );

              const newMatches = groups.flatMap(group =>
                group.teams?.flatMap((team1, i) =>
                  group.teams?.slice(i + 1).map(team2 => {
                    const dupla1 = `${team1.atleta1}/${team1.atleta2}`;
                    const dupla2 = `${team2.atleta1}/${team2.atleta2}`;
                    const matchKey = `${group.name}|${dupla1}|${dupla2}`;

                    if (!existingMatches.has(matchKey)) {
                      return {
                        id: crypto.randomUUID(),
                        rodada: group.name,
                        dupla1,
                        dupla2,
                        placar: { dupla1: 0, dupla2: 0 }
                      };
                    }
                    return null;
                  }).filter(Boolean)
                ));

              onUpdateMatches([...matches, ...newMatches]);
            }}
            className="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700"
          >
            Gerar Confrontos dos Grupos
          </button>

          <button
            onClick={generateSemifinals}
            className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
          >
            Gerar Semifinais
          </button>

          <button
            onClick={generateFinalMatches}
            className="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700"
          >
            Gerar Final e 3º Lugar
          </button>
        </div>

        {groups.map(group => (
          <div key={group.id} className="mb-6">
            <h3 className="font-bold mb-2 text-lg">Grupo {group.name}</h3>
            <div className="bg-gray-50 p-4 rounded-md">
              {calculateStandings(group).map(({ team, wins, saldo, pa }, index) => (
                <div key={team} className="flex justify-between items-center mb-2 p-2 bg-white rounded shadow-sm">
                  <div className="flex items-center gap-3">
                    <span className="font-medium w-8">{index + 1}º</span>
                    <span className="font-semibold">{team}</span>
                  </div>
                  <div className="text-sm text-gray-600">
                    <span className="bg-green-100 px-2 py-1 rounded">{wins} V</span>
                    <span className="mx-2">|</span>
                    <span className="bg-blue-100 px-2 py-1 rounded">{saldo} SP</span>
                    <span className="mx-2">|</span>
                    <span className="bg-purple-100 px-2 py-1 rounded">{pa} PA</span>
                  </div>
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

=== ./src\components\Swords.tsx ===
import React, { useState } from 'react';
import type { Match, Team } from '../types';

interface Props {
  teams: Team[];
  matches?: Match[];
  onUpdate: (matches: Match[]) => void;
}

export default function SwordsC({ matches = [], onUpdate }: Props) {
  const [selectedMatch, setSelectedMatch] = useState<Match | null>(null);
  const [tempScore, setTempScore] = useState({ dupla1: 0, dupla2: 0 });

  const isValidScore = (score1: number, score2: number) => {
    const maxScore = Math.max(score1, score2);
    const minScore = Math.min(score1, score2);
    return (maxScore === 21 && minScore < 20) || (maxScore >= 20 && (maxScore - minScore === 2));
  };

  const handleScoreChange = (field: 'dupla1' | 'dupla2', value: string) => {
    setTempScore(prev => ({ ...prev, [field]: parseInt(value) || 0 }));
  };

  const saveScore = () => {
    if (selectedMatch && isValidScore(tempScore.dupla1, tempScore.dupla2)) {
      const updated = matches.map(m =>
        m.id === selectedMatch.id ? { ...m, placar: tempScore } : m
      );
      onUpdate(updated);
      setSelectedMatch(null);
    }
  };

  return (
    <div className="p-6">
      <div className="bg-white p-6 rounded-lg shadow-md">
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* Grupos */}
          <div>
            <h3 className="text-lg font-bold mb-4">Partidas dos Grupos</h3>
            {[...new Set(matches?.map(m => m.rodada))].map(group => (
              <div key={group} className="mb-6">
                <h4 className="font-medium mb-2">{group}</h4>
                {(matches || []).filter(m => m.rodada === group).map(match => (
                  <div
                    key={match.id}
                    className="bg-gray-50 p-3 rounded-md mb-2 cursor-pointer hover:bg-gray-100"
                    onClick={() => {
                      setSelectedMatch(match);
                      setTempScore(match.placar);
                    }}
                  >
                    <div className="flex justify-between items-center">
                      <span className="flex-1 text-right">{match.dupla1}</span>
                      <span className="mx-3 font-bold">vs</span>
                      <span className="flex-1 text-left">{match.dupla2}</span>
                    </div>
                    {match.placar.dupla1 + match.placar.dupla2 > 0 && (
                      <div className={`text-center mt-2 font-medium ${isValidScore(match.placar.dupla1, match.placar.dupla2)
                        ? 'text-green-600'
                        : 'text-red-600'
                        }`}>
                        {match.placar.dupla1} - {match.placar.dupla2}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            ))}
          </div>

          {/* Fases Eliminatórias */}
          <div>
            <h3 className="text-lg font-bold mb-4">Fases Eliminatórias</h3>
            {['Semifinal', 'Terceiro Lugar', 'Final'].map(stage => (
              <div key={stage} className="mb-6">
                <h4 className="font-medium mb-2">{stage}</h4>
                {(matches || []).filter(m => m.rodada === stage).map(match => (
                  <div
                    key={match.id}
                    className="bg-gray-50 p-3 rounded-md mb-2 cursor-pointer hover:bg-gray-100"
                    onClick={() => {
                      setSelectedMatch(match);
                      setTempScore(match.placar);
                    }}
                  >
                    <div className="flex justify-between items-center">
                      <span>{match.dupla1}</span>
                      <span className="mx-2">vs</span>
                      <span>{match.dupla2}</span>
                    </div>
                    {match.placar.dupla1 + match.placar.dupla2 > 0 && (
                      <div className={`text-center mt-2 font-medium ${isValidScore(match.placar.dupla1, match.placar.dupla2)
                        ? 'text-green-600'
                        : 'text-red-600'
                        }`}>
                        {match.placar.dupla1} - {match.placar.dupla2}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            ))}
          </div>
        </div>

        {/* Modal de Edição */}
        {selectedMatch && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
            <div className="bg-white p-6 rounded-lg shadow-lg w-96">
              <h2 className="text-xl font-bold mb-4">Editar Placar</h2>
              <div className="flex items-center justify-center gap-4 mb-4">
                <div className="text-center">
                  <input
                    type="number"
                    value={tempScore.dupla1}
                    onChange={(e) => handleScoreChange('dupla1', e.target.value)}
                    className="w-20 text-center text-xl p-2 border rounded-md"
                    min="0"
                  />
                  <div className="mt-2 text-sm text-gray-600">{selectedMatch.dupla1}</div>
                </div>
                <span className="text-2xl font-bold">x</span>
                <div className="text-center">
                  <input
                    type="number"
                    value={tempScore.dupla2}
                    onChange={(e) => handleScoreChange('dupla2', e.target.value)}
                    className="w-20 text-center text-xl p-2 border rounded-md"
                    min="0"
                  />
                  <div className="mt-2 text-sm text-gray-600">{selectedMatch.dupla2}</div>
                </div>
              </div>
              <div className="flex gap-2">
                <button
                  onClick={saveScore}
                  className="flex-1 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700"
                >
                  Salvar
                </button>
                <button
                  onClick={() => setSelectedMatch(null)}
                  className="flex-1 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300"
                >
                  Cancelar
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

=== ./src\components\TeamFormation.tsx ===
import React, { useState } from 'react';
import type { Athlete, Team } from '../types';

interface Props {
  athletes: Athlete[];
  teams: Team[];
  onUpdate: (teams: Team[]) => void;
}

export default function TeamFormation({ athletes, teams, onUpdate }: Props) {
  const [athlete1, setAthlete1] = useState('');
  const [athlete2, setAthlete2] = useState('');
  const [grupo, setGrupo] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!athlete1 || !athlete2) return;

    const isDuplicate = teams.some(team =>
      (team.atleta1 === athlete1 && team.atleta2 === athlete2) ||
      (team.atleta1 === athlete2 && team.atleta2 === athlete1)
    );

    if (isDuplicate) {
      alert('Dupla já cadastrada!');
      return;
    }

    const newTeam: Team = {
      id: teams.length + 1,
      atleta1: athlete1,
      atleta2: athlete2,
      grupo,
    };

    onUpdate([...teams, newTeam]);
    setAthlete1('');
    setAthlete2('');
    setGrupo('');
  };

  // Função para remover uma dupla
  const handleRemoveTeam = (teamId: number) => {
    const updatedTeams = teams.filter(team => team.id !== teamId);
    onUpdate(updatedTeams);
  };

  return (
    <div>
      <h2 className="text-2xl font-bold mb-6">Formação de Duplas</h2>

      <form onSubmit={handleSubmit} className="mb-8">
        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Atleta 1
            </label>
            <select
              value={athlete1}
              onChange={(e) => setAthlete1(e.target.value)}
              className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            >
              <option value="">Selecione um atleta</option>
              {athletes.map((athlete) => (
                <option key={athlete.id} value={athlete.nome}>
                  {athlete.nome}
                </option>
              ))}
            </select>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Atleta 2
            </label>
            <select
              value={athlete2}
              onChange={(e) => setAthlete2(e.target.value)}
              className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            >
              <option value="">Selecione um atleta</option>
              {athletes
                .filter((athlete) => athlete.nome !== athlete1)
                .map((athlete) => (
                  <option key={athlete.id} value={athlete.nome}>
                    {athlete.nome}
                  </option>
                ))}
            </select>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Grupo
            </label>
            <select
              value={grupo}
              onChange={(e) => setGrupo(e.target.value)}
              className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            >
              <option value="">Selecione um grupo</option>
              <option value="A">Grupo A</option>
              <option value="B">Grupo B</option>
              <option value="C">Grupo C</option>
              <option value="D">Grupo D</option>
            </select>
          </div>
        </div>

        <button
          type="submit"
          className="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
        >
          Criar Dupla
        </button>
      </form>

      <div className="bg-gray-50 rounded-lg p-4 mt-8">
        <h3 className="text-lg font-semibold mb-4">Duplas Cadastradas</h3>
        {teams.length === 0 ? (
          <p className="text-gray-500">Nenhuma dupla cadastrada</p>
        ) : (
          <ul className="space-y-2">
            {teams.map((team) => (
              <li
                key={team.id}
                className="flex items-center justify-between bg-white p-3 rounded-md shadow-sm"
              >
                <div className="flex-1">
                  <span className="font-medium">{team.atleta1}</span> e{' '}
                  <span className="font-medium">{team.atleta2}</span>
                  {team.grupo && (
                    <span className="ml-4 text-gray-600">
                      (Grupo: {team.grupo})
                    </span>
                  )}
                </div>
                <div className="flex items-center gap-4">
                  <button
                    onClick={() => handleRemoveTeam(team.id)}
                    className="text-red-600 hover:text-red-800 font-medium"
                    title="Remover dupla"
                  >
                    Remover
                  </button>
                </div>
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>
  );
}

=== ./src\components\VotingSystem.tsx ===
import React, { useState } from 'react';
import type { Athlete, Match, RoundVotes } from '../types';

interface Props {
  athletes: Athlete[];
  matches: Match[];
  votes: RoundVotes;
  onUpdate: (votes: RoundVotes) => void;
}

export default function VotingSystem({ athletes, matches, votes, onUpdate }: Props) {
  const [selectedMatchId, setSelectedMatchId] = useState('');
  const [voter, setVoter] = useState('');
  const [votedFor, setVotedFor] = useState('');

  // Obter atletas do confronto selecionado
  const getMatchAthletes = () => {
    if (!selectedMatchId) return [];

    const match = matches.find(m => m.id === selectedMatchId);
    if (!match) return [];

    // Extrair nomes dos atletas das duplas
    const allPlayers = [
      ...match.dupla1.split('/'),
      ...match.dupla2.split('/')
    ];

    return athletes.filter(athlete =>
      allPlayers.includes(athlete.nome)
    );
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!selectedMatchId || !voter || !votedFor) return;

    const match = matches.find(m => m.id === selectedMatchId);
    if (!match) return;

    const roundKey = match.rodada.toLowerCase().replace(/\s+/g, '-');
    const roundVotes = votes[roundKey] || [];
    const newVote = { votante: voter, voto: votedFor };

    onUpdate({
      ...votes,
      [roundKey]: [...roundVotes, newVote],
    });

    setVoter('');
    setVotedFor('');
  };

  return (
    <div>
      <h2 className="text-2xl font-bold mb-6">Sistema de Votação</h2>

      <form onSubmit={handleSubmit} className="mb-8">
        <div className="grid grid-cols-1 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Confronto
            </label>
            <select
              value={selectedMatchId}
              onChange={(e) => setSelectedMatchId(e.target.value)}
              className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            >
              <option value="">Selecione um confronto</option>
              {matches.map((match) => (
                <option key={match.id} value={match.id}>
                  {match.dupla1} vs {match.dupla2} ({match.rodada})
                </option>
              ))}
            </select>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Votante
            </label>
            <select
              value={voter}
              onChange={(e) => setVoter(e.target.value)}
              className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            >
              <option value="">Selecione o votante</option>
              {athletes.map((athlete) => (
                <option key={athlete.id} value={athlete.nome}>
                  {athlete.nome}
                </option>
              ))}
            </select>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Voto para Melhor Atleta
            </label>
            <select
              value={votedFor}
              onChange={(e) => setVotedFor(e.target.value)}
              className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
              disabled={!selectedMatchId} // Desabilita se nenhum confronto for selecionado
            >
              <option value="">Selecione o atleta</option>
              {getMatchAthletes()
                .filter((athlete) => athlete.nome !== voter) // Remove o votante da lista de votáveis
                .map((athlete) => (
                  <option
                    key={athlete.id}
                    value={athlete.nome}
                  >
                    {athlete.nome}
                  </option>
                ))}
            </select>
          </div>
        </div>

        <button
          type="submit"
          className="mt-4 w-full px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          disabled={!selectedMatchId || !voter || !votedFor} // Desabilita o botão se faltar algum campo
        >
          Registrar Voto
        </button>
      </form>

      <div className="bg-gray-50 rounded-lg p-4">
        <h3 className="text-lg font-semibold mb-4">Votos Registrados</h3>
        {Object.keys(votes).length === 0 ? (
          <p className="text-gray-500">Nenhum voto registrado</p>
        ) : (
          <div className="space-y-6">
            {Object.entries(votes).map(([round, roundVotes]) => (
              <div key={round} className="bg-white p-4 rounded-md shadow-sm">
                <h4 className="font-medium mb-3">{round.replace(/-/g, ' ')}</h4>
                <ul className="space-y-2">
                  {roundVotes.map((vote, index) => (
                    <li
                      key={`${round}-${index}`}
                      className="flex justify-between items-center text-sm"
                    >
                      <span className="text-gray-600">{vote.votante}</span>
                      <span className="font-medium">votou em</span>
                      <span className="text-indigo-600">{vote.voto}</span>
                    </li>
                  ))}
                </ul>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}

=== ./src\services\jsonbin.ts ===
import axios from 'axios';
import type { Database } from '../types';
import { initialData } from '../types.ts';

const JSONBIN_API_KEY = '$2a$10$2EXYkBLG9hlyY8HZN7ABKOVwtBKpIsi86FZ72iU8.AJ4SFD92D3Wy'; // Replace with your JSONBin.io API key
const BIN_ID = '67a12c15e41b4d34e4838ee6'; // Replace with your bin ID
const BASE_URL = 'https://api.jsonbin.io/v3/b';

const api = axios.create({
  baseURL: BASE_URL,
  headers: {
    'X-Master-Key': JSONBIN_API_KEY,
    'Content-Type': 'application/json',
  },
});

export async function fetchData(): Promise<Database> {
  try {
    const response = await api.get(`/${BIN_ID}/latest`);
    return {
      ...initialData,
      ...response.data.record,
      atletas: response.data.record.atletas || [],
      duplas: response.data.record.duplas || [],
      confrontos: response.data.record.confrontos || [],
      grupos: response.data.record.grupos || []
    };
  } catch (error) {
    console.error('Error fetching data:', error);
    throw new Error(`Failed to fetch data: ${error.message}`);
  }
}

export async function updateData(data: Database): Promise<void> {
  try {
    await api.put(`/${BIN_ID}`, data);
  } catch (error) {
    console.error('Error updating data:', error);
    throw new Error(`Failed to update data: ${error.message}`);
  }
}

